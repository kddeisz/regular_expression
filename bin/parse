#!/usr/bin/env ruby
# frozen_string_literal: true

$:.unshift(File.expand_path("../lib", __dir__))
require "bundler/setup"
require "regular_expression"
require "crabstone"
require "graphviz"

unless `which dot`.chomp.end_with?("dot")
  warn "YOU HAVE NOT INSTALLED GRAPHVIZ. We found no 'dot' in your path.\n" \
       " Please install Graphviz if you want dotfile visual output to work."
end

# Pass the source through the various parsing phases
#
source = ARGV.shift

ast = RegularExpression::Parser.new.parse(source)
RegularExpression::AST.to_dot(ast)

nfa = ast.to_nfa
RegularExpression::NFA.to_dot(nfa)
dfa = RegularExpression::DFA.build(nfa)
RegularExpression::NFA.to_dot(dfa, filename: "dfa")

bytecode = RegularExpression::Bytecode.compile(nfa)
puts "#{bytecode.dump}\n"

cfg = RegularExpression::CFG.build(bytecode)
puts "#{cfg.dump}\n"
RegularExpression::CFG.to_dot(cfg)

schedule = RegularExpression::Scheduler.schedule(cfg)
puts "#{RegularExpression::Scheduler.dump(cfg, schedule)}\n"

ruby = RegularExpression::Compiler::Ruby.compile(cfg, schedule)
puts "#{ruby.source}\n"

x86 = RegularExpression::Compiler::X86.compile(cfg, schedule)
puts "#{x86.disasm}\n"

check =
  if ARGV.any?
    lambda do |compiled|
      checker = compiled.to_proc
      ARGV.each { |string| puts "#{string}: #{checker.call(string).inspect}" }
      puts
    end
  else
    ->(_compiled) {}
  end

# Test the interpreter against any passed strings
interpreter = RegularExpression::Interpreter.new(bytecode)
check.call(interpreter)

# Test Ruby against any passed strings
check.call(ruby)

# Test x86 against any passed strings
check.call(x86)
